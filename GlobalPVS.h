/*******************************************************************************
 * file:	GlobalPVS.h
 * author:	A.Vlashchuk
 * version:	V1.0.0
 * date:	17-Ќо€бр€-2015
 * brief:	’едер дл€ GlobalPVS.c
 *******************************************************************************/
#ifndef __GLOBALPVS_H
#define __GLOBALPVS_H

#include "PVS.h"
#include "Flash.h"

#define BB_ALIAS(bit_band)	((bit_band&0xF0000000UL)+0x02000000UL+((bit_band&0x000FFFFFUL)*32))

#define	PVS_CONFIG_BYTES sizeof(sPVSConfig)				// длина в байтах c CRC
#define PVS_CONFIG_HWORDS ((PVS_CONFIG_BYTES)/2)		// длина в полусловах с CRC

union defFlags
{
	uint32_t uiFlags;
	struct
	{
	uint32_t
	  bAD7689	:	1,									// данные ј÷ѕ AD7689 готовы
	  bAD5662	:	1,									// данные ÷јѕ AD5662 готовы
	  b100uS	:	1,									// флаг 100мкс
	  bStartT	:	1;									// старт измерени€ тахометра
	};
};

extern volatile union defFlags unFlags;					// флаги

struct defBBFlags
{
uint32_t
	bAD7689,											// данные ј÷ѕ AD7689 готовы
	bAD5662,											// данные ÷јѕ AD5662 готовы
	b100uS,												// флаг 100мкс
	bStartT;											// старт измерени€ тахометра
};

extern volatile struct defBBFlags *pBBFlags;			// область alias bit-band SRAM

//==============================================================================
//	√лобальные переменные
//==============================================================================
// ¬нешние ссылки на глобальные переменные
//------------------------------------------------------------------------------
extern volatile uint16_t usBufDMA_SPI3[2];						// буфер DMA выходного ÷јѕа (AD5662)
extern volatile uint16_t usBuf_AD7689[BUF_AD7689_SIZE];			// кольцевой буфер ј÷ѕ AD7689
extern volatile uint16_t usBuf_AD5662[BUF_AD5662_SIZE]; 		// кольцевой буфер ÷јѕ AD5662

extern volatile	uint8_t	ucInBuf_RS485[RX_BUF_RS485_SIZE];		// кольцевой буфер чтени€ с RS485 (входной буфер)
extern volatile	uint8_t ucOutBuf_RS485[TX_BUF_RS485_SIZE];		// кольцевой буфер записи в RS485 (выходной буфер)

extern volatile	uint32_t wr_index_AD7689, rd_index_AD7689;		// индексы записи и чтени€ кольцевого буфера ј÷ѕ AD7689
extern volatile	uint32_t wr_index_AD5662, rd_index_AD5662;		// индексы записи и чтени€ кольцевого буфера ÷јѕ AD5662

extern volatile	uint32_t wr_index_RxRS485, rd_index_RxRS485;	// индексы записи и чтени€ входного кольцевого буфера RS485
extern volatile	uint32_t wr_index_TxRS485, rd_index_TxRS485;	// индексы записи и чтени€ выходного кольцевого буфера RS485



struct MainCfg
{
	uint16_t
	  bPVS		:	2,					// bit1Е0 (тип преобразовател€):
										//				0 Ц ѕќ¬ (осевой сдвиг)
										//				1 Ц ѕ«¬ (мгновенных значений зазора, default)
										//				2 Ц ѕ¬¬ (вибраци€)
  	  bRangeD	:	2,					// bit3Е2 (диапазон измерени€ датчика):
										//				0 Ц 2 мм (+/-1 мм) (default)
										//				1 Ц 4 мм (+/-2 мм)
										//				2 Ц 5 мм (+/-2,5 мм)
	  bRangeV	:	2,					// bit5Е4 (диапазон измерени€ вибрации)
	  									//				0 - 10...125 мкм (default)
	  									//				1 - 15...250 мкм
	  									//				2 - 25...500 мкм
	  bFmtOut	:	1,					// bit6 (тип аналогового выхода)
										//				0 Ц I (4Е20мј, default)
										//				1 Ц U (отрицательное напр€жение)
	  bMode		:	2,					// bit8,7 (выдача на выход I 4Е20мј)
										//				0 Ц –≈∆.2 (Ќќ–ћальна€ работа)
										//				1 Ц –≈∆.1 («ј«ќ–)
	  									//				2 - ѕереключатель –≈∆»ћ, default (переключатель –≈∆»ћ устанавливает режим роботы: –≈∆.1 или –≈∆.2)
	  bLPF		:	2,					// bit10,9 (частота пропускани€ ‘Ќ„, крутизна 18 дЅ/октава)
										//				0 Ц 500 √ц
										//				1 Ц 1000 √ц (default 1)
										//				2,3 - LPF отключен
	  bHPF		:	2,					// bit12,11 (частота пропусканн€ ‘¬„ 18 дЅ/октава) - дл€ ѕ¬¬
										//				0 Ц 5 √ц
										//				1 Ц 10 √ц (default 1)
	  									//				2,3 - ‘¬„ отключен
	  bLPFD		:	3;					// bit15Е13 (врем€ усреднени€ выходного результата - текущее среднее) - дл€ ѕќ¬ и ѕ¬¬
										//				0 Ц фильтр отключен (default)
										//				1 Ц 0,1с
										//				2 Ц 0,2с
										//				3 Ц 0,4с
										//				4 Ц 0,8с
										//				5 Ц 1,6с
										//				6 Ц 3,2с
  	  									//				7 - 6,4c
};

struct CallibrCfg
{
	uint16_t
	  bNCal		:	4,					// bit3Е0 (калибровка при нормальных услови€х):
										//				0 Ц калибровка по 7 точках (1,2,3,4,5,6,7) - default
										//				1...15 - недопустимо
	  bTMCal:		4,					// bit7Е4 (калибровка при повышеной температуре по температуре модул€)
                                        //				0 - отключение калибровки по температуре модул€ - default
                                        //				1 - калибровка по 1 точке (8)
                                        //				2 - калибровка по 2 точках (8,9)
	  bTDCal:		4,					// bit11Е8 (калибровка при повышеной температуре в зависимости от температуры датчика)
                                        //				0 - отключение калибровки по температуре датчика - default
                                        //				1 - калибровка по 1 точке (8)
                                        //				2 - калибровка по 2 точках (8,9)
	  bRTD:			4;					// bit15Е12 (сопротивление кабел€ измерител€ температуры датчика)
              							//				0 - 0 ќм - default
                                        //				1 - 0,2 ќм (длина кабел€ 1м, ћ√“‘-0,2)
										//				2 Ц 0,4 ќм (длина кабел€ 2м, ћ√“‘-0,2)
										//				3 Ц 0,6 ќм (длина кабел€ 3м, ћ√“‘-0,2)
                                        //				4 - 0,8 ќм (длина кабел€ 4м, ћ√“‘-0,2)
                                        //				5 - 1,0 ќм (длина кабел€ 5м, ћ√“‘-0,2)
                                        //				6 - 1,2 ќм (длина кабел€ 6м, ћ√“‘-0,2)
                                        //				7 - 1,4 ќм (длина кабел€ 7м, ћ√“‘-0,2)
                                        //				8 - 1,6 ќм (длина кабел€ 8м, ћ√“‘-0,2)
                                        //				9 - 1,8 ќм (длина кабел€ 9м, ћ√“‘-0,2)
                                        //				10 - 2,0 ќм (длина кабел€ 10м, ћ√“‘-0,2)
                                        //				11 - 2,2 ќм (длина кабел€ 11м, ћ√“‘-0,2)
                                        //				12 - 2,4 ќм (длина кабел€ 12м, ћ√“‘-0,2)
                                        //				13 - 2,6 ќм (длина кабел€ 13м, ћ√“‘-0,2)
                                        //				14 - 2,8 ќм (длина кабел€ 14м, ћ√“‘-0,2)
                                        //				15 - 3,0 ќм (длина кабел€ 15м, ћ√“‘-0,2)
};

struct PVSConfig
{
	uint8_t 	MbAddr;					// 0		// адрес на шине ModBus (1Е247, default 1)
	uint8_t		MbBRP;					// 				BaudRate и Parity
										//				bits 3...0 - BaudRate:	0 - 1200, 1 - 2400, 2 - 4800, 3 - 9600,
										// 					4 Ц 19200 (default), 5 - 38400, 6 - 56000, 7 Ц 115200
										// 					--------------- на будущее ---------------------------
										//					8 - 76800, 9 - 153600, 10 - 230400, 11 - 307200,
										//					12 - 460800, 13 - 614400, 14 - 921600, 15 - 1228800
										//					------------------------------------------------------
										//				bits 7...4 - Parity:	0 Ц EVEN (default), 1 - ODD, 2 Ц NONE
	struct 		MainCfg;				// 1
	struct		CallibrCfg;				// 2
    uint8_t		TypePVS[4];				// 3,4		//	тип PVS (текст: PVS - текущий PVS, PVS1 - модернизований PVS, PVS2 - 2-канальный PVS)
	uint16_t	NumPVS;					// 5		//	bit15Е0 Ц заводской номер преобразовател€ (1...65536, где 0 - 65536)
	uint16_t	VersPVS;				// 6		//	bit15Е0 Ц верси€ ѕќ (4 цифры в 2/10 коде в формате XX.X.X)
	uint16_t	ProductDate[2];			// 7,8		//	дата последней калибровки (в 2/10 коде):
										//				ProductDate[0] - день и мес€ц изготовлени€ (bit15Е8 Ц мес€ц, bit7Е0 Ц день)
										//				ProductDate[1] - год изготовлени€
	uint16_t	CallibrDate[2];			// 9,10		//	дата последней калибровки (в 2/10 коде):
										//				CallibrDate[0] - день и мес€ц калибровки (bit15Е8 Ц мес€ц, bit7Е0 Ц день)
										//				CallibrDate[1] - год калибровки
	uint8_t		LabelPVS[20];			// 11...20	//	маркировка PVS (до 20 символов)
	uint8_t		Material[10];			// 21...25	//	марка материала гребн€ (до 10 символ≥в)
	int16_t		umCallibr[7];			// 26...32	//	точки калибровки нелинейности, в мкм
										//				umCallibr[0] Ц нижн€€ граница аварии
										//				umCallibr[6] Ц верхн€€ граница аварии
	int16_t		umCallibr0;				// 33		//	"0" калибровочной кривой дл€ ѕќ¬, в мкм
	uint16_t	vNCallibr[7];			// 34...40	//	точки калибровки нелинейности при нормальных услови€х, в показани€х ј÷ѕ
										//				vNCallibr[0] Ц нижн€€ граница аварии
										//				vNCallibr[6] Ц верхн€€ граница аварии
	uint16_t	vTCallibr[2];			// 41,42	//	точки калибровки по температуре при нормальной температуре, в показани€х ј÷ѕ
										//				vTCallibr[0] Ц перва€ точка калибровки (т.8)
										//				vTCallibr[1] Ц втора€ точка калибровки (т.9)
	uint16_t	vTMCallibr[2];			// 43,44	//	точки калибровки по температуре при повышенной температуре модул€, в показани€х ј÷ѕ
										//				vTMCallibr[0] Ц перва€ точка калибровки (т.8)
										//				vTMCallibr[1] - втора€ точка калибровки (т.9)
	uint16_t	vTDCallibr[2];			// 45,46	//	точки калибровки по температуре при повышенной температуре датчика, в показани€х ј÷ѕ
										//				vTDCallibr[0] Ц перва€ точка калибровки (т.8)
										//				vTDCallibr[й] Ц втора€ точка калибровки (т.9)
	int16_t		TNMCallibr;				// 47		//  температура калибровки при нормальных услови€х модул€, в град
	int16_t		TMCallibr;				// 48		//	температура калибровки при повышенной температуре модул€, в град
	int16_t		TNDCallibr;				// 49		//  температура калибровки при нормальных услови€х датчика, в град
	int16_t		TDCallibr;				// 50		//	температура калибровки при повышенной температуре датчика, в град
	int16_t		TMFault;				// 51		//	температура аварии модул€, в град
	int16_t		TDFault;				// 52		//	температура аварии датчика, в град
	int16_t		tClearFault;			// 53		//	врем€ сн€ти€ сигнала Ђјвари€ї (0...10с с дискретностью 0,1с)
	int16_t		umGapL;					// 54		//	«ј«ќ–1 - меньший зазор датчика тахометра, мкм
	int16_t		umGapH;					// 55		//	«ј«ќ–2 - больший зазор датчика тахометра, мкм
	int16_t		umPR1;					// 56		//	”ставка ѕ–1 ѕ¬¬, мкм
	int16_t		umPR2;					// 57		//	”ставка ѕ–2 ѕ¬¬, мкм
	int16_t		umFailure;				// 58		//	”ставка ј¬ј–»я ѕ¬¬, мкм
	int16_t		tDelaySignal;			// 59		//	”ставка задержки сигнализации “с (0...10с с дискретностью 0,1с)
	uint8_t		Password[4];			// 60,61	//	рабочий пароль (4 знака в коде ASCII, измен€емый: " Ћё„"). «амена парол€ только при корректном мастер-пароле.
	uint8_t		MasterPass[4];			// 62,63	//	мастер-пароль (4 знака в коде ASCII, неизменный: "NAEK").
	uint16_t	CRC16;					// 64		//	CRC16
};										// всего 130 байт (128 без CRC)

extern const struct PVSConfig cPVSConfig;		// структура cPVSConfig в 3 секторе Flash
extern struct PVSConfig sPVSConfig;				// структура sPVSConfig в SRAM

struct	BitLeap
{
	uint16_t
	  bRes1				:	14,			//			//
	  bStartLeap		:	1,			//			// ѕ”— /—“ќѕ
	  bClearLeap		:	1;			//			// —Ѕ–ќ—
};

struct	BitTrend
{
	uint16_t
	  bTime				:	8,			// bit7...0 // 1...72год або 1...72с
	  bTrendTest		:	1,			// bit 8	// 0 - bTime в часах, 1 - в секундах
	  bRes2				:	4,			// bit12...9//
	  bWriteTime		:	1,			// bit 13	// «апис Time
	  bStartTrend		:	1,			// bit 14	// ѕ”— /—“ќѕ
	  bClearTrend		:	1;			// bit 15	// —Ѕ–ќ—
};

struct PVSControl						// 0x4000	// базовый адрес Holding Registers 0x4000, управление PVS (ќ«”)
{
	union
    {
		uint16_t	wLeap;				// 0		// —качок
        struct		BitLeap; 
    };
	union
    {
		uint16_t	wTrend;				// 1		// “ренд
        struct		BitTrend;
    };
};

extern struct PVSControl sPVSControl;	// структура sPVSControl в SRAM

union	ErrPVS
{
	uint16_t	usErrPVS;
	struct
	{
		uint16_t
		  bErrAll		:	1,			// люба€ ошибка
		  bErrFlash		:	1,			// ошибка структуры во Flash
		  bErrTempM		:	1,			// температура модул€ PVS выше температуры аварии
		  bErrTempS		:	1,			// температура датчика выше температуры аварии
		  bErrP5VA		:	1,			// +5VA не в диапазоне +4,9...+5,1¬
		  bErrM5VA		:	1,			// -5VA не в диапазоне -4,8...+5,2¬
		  bErrDatchL	:	1,			// ошибка датчика (приближение)
		  bErrDatchH	:	1,			// ошибка датчика (выше верхней точки)
		  bErrBrakeLine	:	1;			// ошибка линии выходного канала (I или U в зависимости от конфигурации)
	};
};

union defModBus
{
	uint16_t usModBus;
	struct
	{
		uint16_t
		  bReg			:	2,			// режим ModBus: 0 - IDLE, 1 - прием, 2 - парсинг и отработка, 3 - передача
		  bPErr			:	1,			// ошибка четности
		  bT1_5Err		:	1;			// межсимвольна€ ошибка
	};
};

extern union defModBus unModBus;

union BitState
{
  	uint16_t	usBitState;
	struct
	{
		uint16_t
		  bREGIM		:	1,			// положение переключател€ –≈∆»ћ (0 - –еж.2 - –ј«ћј’ ¬»Ѕ–ќѕ≈–≈ћ≈ў≈Ќ»… / “ј’ќћ≈“–, 1 - реж.1 - «ј«ќ–)
		  bHL1			:	1,			// состо€ние светодиода HL1 (RS485): 1 - On, 0 - off
		  bHL2Red		:	1,			// состо€ние светодиода HL2Red (1 - On, 0 - off)
		  bHL2Green		:	1,			// состо€ние светодиода HL2Green (1 - On, 0 - off)
		  bSync			:	1,			// подключение входа внешней синхронизации (1 - подключено, 0 - нет)
		  								//		критерий - рассто€ние между импульсами < 60/1 = 60с = 1мин
		  bControl		:	1,			// состо€ние кнопки  ќЌ“–ќЋ№ (0 - не нажата, 1 - нажата)
		  bWork			:	1,			// режим работы InitCofig/Work (0 - "InitConfig", 1 - "Work")
		  bSyncP		:	1,			// 1 - обнаружен импульс синхронизации на входе PB10 (TIM2_CH3)
		  bTMes			:	1,			// 1 - измерение длительности импульсов в тахометре
		  bConfig		:	1,			// 1 - произошло изменение конфигурации (не включа€ изменение параметров интерфейса RS485 в sPVSConfig)
		  bRS485		:	1;			// 1 - произошло изменение параметров интерфейса RS485 (не включа€ изменение остальных параметров sPVSConfig)
	};
};

union BitSygnal
{
   	uint16_t	usBitSygnal;
	struct
	{
        uint16_t
          bPR1			:	1,			// bit0 - ѕ–≈ƒ”ѕ–≈∆ƒ≈Ќ»≈ 1
          bPR2			:	1,			// bit1 - ѕ–≈ƒ”ѕ–≈∆ƒ≈Ќ»≈ 2
          bFailure		:	1,			// bit2 - ј¬ј–≤я
          bLeap			:	1,			// bit3 - — ј„ќ 
          bLeapEnable	:	1,			// bit4 - — ј„≈  ƒќ«¬ќЋ≈Ќќ
          bTrend		:	1,			// bit5 - “–≈Ќƒ
          bTrendEnable	:	1,			// bit6 - “–≈Ќƒ ƒќ«¬ќЋ≈Ќќ
          bTrendTest	:	1;			// bit7 - “–≈Ќƒ “≈—“
	};
};

struct PVSState							// структура состо€ни€. ¬сего 248 байт, с CRC - 250 байт
{
	union		BitState;				// 0		//	структура битов положени€ переключателей LED и т.п.
	union		ErrPVS;					// 1		//	биты ошибок
    union		BitSygnal;				// 2		//	—игнализаци€

	int16_t		shGap;					// 3		//	текущее мгновенное значение зазора без цифровой фильтрации, мкм
	int16_t		shDisplacement;			// 4		//	осевой сдвиг, мкм
	int16_t		shVibration;			// 5		//	размах виброперемещений, мкм

	uint16_t	usA_05;					// 6		//	јмплитуда гармоники 0,5
    uint16_t	usA_1;					// 7		//	јмплитуда гармоники 1
    uint16_t	usA_2;					// 8		//	јмплитуда гармоники 2
    uint16_t	usA_3;					// 9		//	јмплитуда гармоники 3
    int16_t		shF_05;					// 10		//	‘аза гармоники 0,5
    int16_t		shF_1;					// 11		//	‘аза гармон≥ки 1
    int16_t		shF_2;					// 13		//	‘аза гармон≥ки 2
    int16_t		shF_3;					// 13		//	‘аза гармон≥ки 3

	uint16_t	usSpin;					// 14		//	кругова€ скорость вращени€, дискрета 0,1 об/мин
	int16_t		shGapMin;				// 15		//	минимальный зазор за период вращени€
	int16_t		shGapMax; 				// 16		//	максимальный зазор за период вращени€
	int16_t		shBeat[60];				// 17...76	//	мгновенные значени€ зазора/осевого сдвига/ через 6 град (60 отсчетов на оборот)

	int16_t		shTempModule;			// 77		//	измеренна€ температура модул€ PVS, град.—
	int16_t		shTempSensor;			// 78 		//	измеренна€ температура датчика PVS, град.—
	uint16_t	usDataADC;				// 79		//	данные ј÷ѕ (дл€ калибровки)
	uint16_t	usDataOut;				// 80		//	данные дл€ выдачи на выходной ÷јѕ (без ошибки)
	int16_t		shP5VA;					// 81		//	напр€жение питани€ +5VA, м¬
	int16_t		shM5VA;					// 82		//	напр€жение питани€ -5VA, м¬
	uint32_t	CRC32;					// 83,84	//	CRC32 программы во флеш, подсчитанна€ в процессе работы

	float		fKx[6];					// 85...96	//	наклон калибровочной кривой в точках калибровки (при нормальной температуре)
	float		fumCallibr[7];			// 97...110	//	точки калибровки в мкм (при нормальной температуре)
	float		fvNCallibr[7];			// 111...124//	точки калибровки в отсчетах ј÷ѕ (при нормальной температуре)
	float		fumCallibr0;			// 125,126	//	"0" калибровочной кривой дл€ ѕќ¬, в мкм  (при нормальной температуре)
	float		fK1xTM;					// 127,128	//	коэффициент 1 калибровки по температуре модул€
	float		fK2xTM;					// 129,130	//	коэффициент 2 калибровки по температуре модул€
	float		fK1xTD;					// 131,132	//	коэффициент 1 калибровки по температуре датчика
	float		fK2xTD;					// 133,134	//	коэффициент 2 калибровки по температуре датчика
	float		fumTCallibr[2];			// 135...138//	точки калибровки в мкм (по температуре)
	float		fvTCallibr[2];			// 139...142//	точки калибровки в отсчетах ј÷ѕ дл€ нормальной температуры
	float		fKPt;					// 143,144	//	коэффициент преобразовани€ Pt (платинового терморезистора) дл€ вычислени€ температуры
};

extern struct PVSState sPVSState;		// структура PVSState в SRAM

extern const float cfKU[3];				// наклон кривой вых. напр€жени€ от диапазона измерени€ датчика (sPVSConfig.bRangeD)
extern const float cfKI[3];				// наклон кривой вых. тока от диапазона измерени€ датчика (sPVSConfig.bRangeD)
extern const float cfKIV[3];			// наклон кривой вых. тока от диапазона измерени€ размаха виброперемещени€(sPVSConfig.bRangeV)
extern const uint16_t cusUOUT_0[3];  	// начальное значение UOUT
extern const uint32_t *pcCRC32;			// указатель на CRC32 программы во флеши

#endif /* __GLOBALPVS_H */
